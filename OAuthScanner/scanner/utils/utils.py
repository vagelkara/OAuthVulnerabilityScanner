import json
from urllib.parse import urlparse, urlunparse
from pathlib import Path
import requests
from reporter import Reporter
from bs4 import BeautifulSoup
from http.cookies import SimpleCookie
from utils.driver import get_url



config = Path('../config.json')
attr_list = Path('./resources/attr.lst')
reporter = Reporter("utils")
settings_file = Path('../settings.json')

config.touch(exist_ok=True)

def create_conf():
    '''Not used'''
    dictionary ={}
    
    with config.open(mode='w') as outfile:
        json.dump(dictionary, outfile, indent=2)
        outfile.close()

def read_config(config):
    
    settings = {}
    with config.open() as cfg:
        json_object = json.load(cfg)
        for key, val in json_object.items():
            settings[key] = val
        cfg.close()
    return settings

def read_key_from_config(key,config=config):

    val = None
    with config.open() as cfg:
        json_object = json.load(cfg)
        if key in json_object:
            val = json_object[key]
        cfg.close()
    
    return val 

def update_conf(key,value):
    
    with config.open(mode="r") as jsonFile:
        data = json.load(jsonFile)
    
    data[key] = value

    with config.open(mode="w") as jsonFile:
        json.dump(data, jsonFile, indent=2)

def del_attr(obj):
    for key, value in obj.copy().items():
        if isinstance(obj[key], dict):
            obj[key] = del_attr(obj[key])
        else:
            if value != 'NONE':
                del obj[key]
    return obj

def remove_key_from_conf(key,config=config):
    with config.open() as data_file:
        data = json.load(data_file)

    f = True if key in data else False
    if f and key != 'NONE':
        del data[key]

    with config.open(mode='w') as data_file:
        data = json.dump(data, data_file, indent=2)

def clear_conf():
    with config.open() as data_file:
        data = json.load(data_file)

    del_attr(data)

    with config.open(mode='w') as data_file:
        data = json.dump(data, data_file, indent=2)

def cookies_from_dict(cookie_dict):
    cookie = SimpleCookie()
    cookie.load(cookie_dict)
    cookies = {k: v.value for k, v in cookie.items()}   
    return cookies     

def has_key(key,diction):
    f = None
    if type(diction) is dict and key in diction:
        f = diction[key]
    return f

def pretty_pring_json(json_data):
    '''Used only for debug processes'''
    reporter.info(json.dumps(json_data, indent=2))

def force_base_url(base_url,info):
    url_lst = [
            "well_known",
            "issuer",
            "authorization_endpoint",
            "token_endpoint",
            "introspection_endpoint",
            "userinfo_endpoint",
            "jwks_uri"
            ]
    for at in url_lst:
        val = info.get(at)
        try:
            parsed = urlparse(val)
            base = urlparse(base_url)
            replaced = parsed._replace(netloc=base.netloc)
            val = urlunparse(replaced)
            if val:
                update_conf(at,val)
        except:
            pass

def get_input_from_list(file=attr_list):
    txt_file = file.open()
    file_content = txt_file.readlines()
    contents = []
    for f in file_content:
        content = f.split(",")[0]
        contents.append(content)
    txt_file.close()
    return contents

def parser(url):
    '''Not used'''
    parsed = urlparse(url)
    scheme = parsed.scheme
    return scheme

def repeater():
    enumeration = Path('./resources/enumerate.lst')
    contents = get_input_from_list(enumeration)
    for c in contents:
        url = c + '/.well-known/webfinger'
        r = requests.get(url)
        reporter.info(r.status_code)

def read_settings():
    settings = {}
    settings = read_config(settings_file)
    return settings

def request_builder( schema,
                    authorization_endpoint, 
                    clientid, 
                    redirect_url, 
                    nonce='', 
                    state='',
                    chal_method='',
                    code_challenge='',
                    scope='email',
                    response_type='code'):        
        postfix = ''
        if clientid == None:
            reporter.error("Clientid not declared")
        
        url = f'{authorization_endpoint}?{schema["client_id"]}={clientid}&{schema["scope"]}={scope}&{schema["response_type"]}={response_type}&{schema["redirect_uri"]}={redirect_url}'
        
        parsed = urlparse(url)
        if parsed.scheme:
            pass
        else:
            issuer = read_key_from_config('issuer') 
            url = issuer.rstrip('\/') + url

        if nonce != '':
            postfix += f'&{schema["nonce"]}={nonce}' 
        if state != '':
            postfix += f'&{schema["state"]}={state}' 
        if chal_method != '':
            postfix += f'&{schema["chal_method"]}={chal_method}' 
        if code_challenge != '':
            postfix += f'&{schema["code_challenge"]}={code_challenge}' 
        url += postfix

        return url

def check_responses(r1,r2):
    d = {
        'status_code': False,
        'equals': False
    }
    if r1.status_code == r2.status_code:
        d['status_code'] = True
    if r1.text == r2.text:
        d['equals'] = True
    
    return d

def define_schema(oauth_vendor):
    schema = {
        "client_id":"client_id",
        "scope":"scope",
        "response_type":"response_type",
        "redirect_uri":"redirect_uri",
        "nonce":"nonce",
        "state":"state",
        "chal_method":"chal_method",
        "code_challenge":"code_challenge"
    }

    if oauth_vendor == "casdoor":
        norm = {
            "client_id":"clientId",
            "response_type":"responseType",
            "redirect_uri":"redirectUri",
            "chal_method":"code_challenge_method"
        }
        schema.update(norm)
    
    if oauth_vendor == "omejdn" or oauth_vendor == "okta":    
        norm = {
            "chal_method":"code_challenge_method"
        }
        schema.update(norm)
        
    return schema

def requestErrorReporter(req , msg=''):
    if req == None :
        s = 'Unhandled'
        if msg:
            e = msg
    else:
        s = req.status_code
        e = 'Bad Request or failed to grab the cookie'
        try:
            soup = BeautifulSoup(req.content, 'html.parser')
            e = soup.find_all("p", {"class": "instruction"})[0].text
        except:
            pass   
    
    reportedError = f'Status Code {s} - Error : {e}'
    
    return reportedError

#TODO:needs refactor
def construct_keycloak_cookie(url):
    
    settings = read_settings()
    #keycloak integration
    cookie_dict = {}
    temp_r = requests.get(url)
    
    if temp_r.ok:
        post_cookies = temp_r.cookies
        soup = BeautifulSoup(temp_r.content, 'html.parser')
        url_post = soup.find_all('form')[0]['action']
        # print(post_cookies)
        username = has_key("username",settings)
        password = has_key("password",settings)
        if username is None or password is None:
            reporter.error("PKCE Downgrade Attacks require an authenticated session. Ensure that have provide it in settings")
            return

        data_post = {"username": settings["username"], "password": settings["password"], "credentialId": ''}
        for cookie in post_cookies:
            if cookie.__dict__["name"] == "AUTH_SESSION_ID":
                cookie_dict["AUTH_SESSION_ID"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "AUTH_SESSION_ID_LEGACY":
                cookie_dict["AUTH_SESSION_ID_LEGACY"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "KC_RESTART":
                cookie_dict["KC_RESTART"] = cookie.__dict__["value"]

        r = requests.post(url_post, cookies=post_cookies, data=data_post, allow_redirects=False)
        # print(r)
        for cookie in r.cookies:
            if cookie.__dict__["name"] == "KEYCLOAK_IDENTITY":
                cookie_dict["KEYCLOAK_IDENTITY"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "KEYCLOAK_IDENTITY_LEGACY":
                cookie_dict["KEYCLOAK_IDENTITY_LEGACY"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "KEYCLOAK_SESSION":
                cookie_dict["KEYCLOAK_SESSION"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "KEYCLOAK_SESSION_LEGACY":
                cookie_dict["KEYCLOAK_SESSION_LEGACY"] = cookie.__dict__["value"]
        
        update_conf("cookie", cookie_dict)
        
    else:
        e = requestErrorReporter(temp_r)
        reporter.error(e)
        return

def construct_cassdoor_cookie(url):

    resp = requests.get(url)
    if resp.ok:
        csrf_cookie_cassdor = cookies_from_dict(resp.cookies)
        payload={"application": "myclient", "autoSignin": True, "organization": "built-in", "password": "123", "phonePrefix": "86", "samlRequest": "", "type": "code", "username": "admin"}
        parsed = urlparse(url)
        posturl = parsed.scheme +'://'+ parsed.netloc + '/api/login?' + parsed.query
        resp_auth = requests.post(posturl, cookies=csrf_cookie_cassdor, json=payload)
        if resp_auth.ok:
            try:
                r = json.loads(resp_auth.content)
                code = has_key('data',r)
                if code is not None:
                    update_conf('extracted_code',code)
                else:
                    msg = has_key('msg',r)
                    reporter.error(f'Failure to extract code from casdoor\'s response - retrieved error message from response{msg}')
            except e:
                reporter.error(e)

        update_conf("cookie", csrf_cookie_cassdor)

def grab_cookie_update_conf(c):
    cookie_dict = {}
    for i in c:
        cookie_dict[i['name']] = i['value']
    
    update_conf("cookie", cookie_dict)

#TODO: (TBD)which will be the default value? (keycloak?)
def construct_cookie(url, nav, selector=None):
    
    vendor = read_key_from_config("oauth_vendor",settings_file)
    print(vendor)
    if nav:
        get_url(url,nav,selector) 
    else:
        if vendor == "casdoor":
            construct_cassdoor_cookie(url)
        elif vendor == "keycloak":
            construct_keycloak_cookie(url)
        else: 
            raise ("Vendor is not known please use 'navigation' mode")

def request_urls(url1, url2, nav):
    r1 = get_url(url1, nav, None)
    r2 = get_url(url2, nav, None)
    return r1,r2
    