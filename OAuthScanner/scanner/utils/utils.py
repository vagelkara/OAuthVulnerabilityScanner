import json
from urllib.parse import urlparse
from pathlib import Path
import requests
from reporter import Reporter
from bs4 import BeautifulSoup
from http.cookies import SimpleCookie




config = Path('../config.json')
attr_list = Path('./resources/attr.lst')
reporter = Reporter("utils")

config.touch(exist_ok=True)

def create_conf():
    '''Not used'''
    dictionary ={}
    
    with config.open(mode='w') as outfile:
        json.dump(dictionary, outfile, indent=2)
        outfile.close()

def read_config(config):
    
    settings = {}
    with config.open() as cfg:
        json_object = json.load(cfg)
        for key, val in json_object.items():
            settings[key] = val
        cfg.close()
    return settings

def read_key_from_config(key,config=config):

    val = None
    with config.open() as cfg:
        json_object = json.load(cfg)
        if key in json_object:
            val = json_object[key]
        cfg.close()
    
    return val 

def update_conf(key,value):
    
    with config.open(mode="r") as jsonFile:
        data = json.load(jsonFile)
    
    data[key] = value

    with config.open(mode="w") as jsonFile:
        json.dump(data, jsonFile, indent=2)

def del_attr(obj):
    for key, value in obj.copy().items():
        if isinstance(obj[key], dict):
            obj[key] = del_attr(obj[key])
        else:
            if value != 'NONE':
                del obj[key]
    return obj

def remove_key_from_conf(key,config=config):
    with config.open() as data_file:
        data = json.load(data_file)

    f = True if key in data else False
    if f and key != 'NONE':
        del data[key]

    with config.open(mode='w') as data_file:
        data = json.dump(data, data_file, indent=2)

def clear_conf():
    with config.open() as data_file:
        data = json.load(data_file)

    del_attr(data)

    with config.open(mode='w') as data_file:
        data = json.dump(data, data_file, indent=2)

def cookies_from_dict(cookie_dict):
    cookie = SimpleCookie()
    cookie.load(cookie_dict)
    cookies = {k: v.value for k, v in cookie.items()}   
    return cookies     

def has_key(key,dict):
    f = None
    if key in dict:
        f = dict[key]
    return f

def pretty_pring_json(json_data):
    '''Used only for debug processes'''
    reporter.info(json.dumps(json_data, indent=2))

def get_input_from_list(file=attr_list):
    txt_file = file.open()
    file_content = txt_file.readlines()
    contents = []
    for f in file_content:
        content = f.split(",")[0]
        contents.append(content)
    txt_file.close()
    return contents

def parser(url):
    '''Not used'''
    parsed = urlparse(url)
    scheme = parsed.scheme
    return scheme

def repeater():
    enumeration = Path('./resources/enumerate.lst')
    contents = get_input_from_list(enumeration)
    for c in contents:
        url = c + '/.well-known/webfinger'
        r = requests.get(url)
        reporter.info(r.status_code)

def read_settings():
    settings = {}
    settings_file = Path('../settings.json')
    settings = read_config(settings_file)
    return settings

def request_builder(authorization_endpoint, 
                    clientid, 
                    redirect_url, 
                    nonce='', 
                    state='',
                    chal_method='',
                    code_challenge='',
                    scope='email',
                    response_type='code'):        
        postfix = ''
        if clientid == None:
            reporter.error("Clientid not declared")
        
        url = f'{authorization_endpoint}?client_id={clientid}&scope={scope}&response_type={response_type}&redirect_uri={redirect_url}'
        
        parsed = urlparse(url)
        if parsed.scheme:
            pass
        else:
            issuer = read_key_from_config('issuer') 
            url = issuer.rstrip('\/') + url

        if nonce != '':
            postfix += f'&nonce={nonce}' 
        if state != '':
            postfix += f'&state={state}' 
        if chal_method != '':
            postfix += f'&chal_method={chal_method}' 
        if code_challenge != '':
            postfix += f'&code_challenge={code_challenge}' 
        url += postfix

        return url

def check_responses(r1,r2):
    d = {}
    if r1.status_code == r2.status_code:
        d['status_code'] = True
    if r1.text == r2.text:
        d['equals'] = True
    
    #!DEBUG
    # print(r1.content)
    # print(r2.content)
    return d

def construct_keycloak_cookie(url):
    
    settings = read_settings()
    #keycloak integration
    cookie_dict = {}
    temp_r = requests.get(url)
    if temp_r.ok:
        post_cookies = temp_r.cookies
        soup = BeautifulSoup(temp_r.content, 'html.parser')
        url_post = soup.find_all('form')[0]['action']
        # print(post_cookies)
        username = has_key("username",settings)
        password = has_key("password",settings)
        if username is None or password is None:
            reporter.error("PKCE Downgrade Attacks require username + password to be performed. Ensure that have provide them in settings")
            return

        data_post = {"username": settings["username"], "password": settings["password"], "credentialId": ''}
        for cookie in post_cookies:
            if cookie.__dict__["name"] == "AUTH_SESSION_ID":
                cookie_dict["AUTH_SESSION_ID"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "AUTH_SESSION_ID_LEGACY":
                cookie_dict["AUTH_SESSION_ID_LEGACY"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "KC_RESTART":
                cookie_dict["KC_RESTART"] = cookie.__dict__["value"]

        r = requests.post(url_post, cookies=post_cookies, data=data_post, allow_redirects=False)
        # print(r)
        for cookie in r.cookies:
            if cookie.__dict__["name"] == "KEYCLOAK_IDENTITY":
                cookie_dict["KEYCLOAK_IDENTITY"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "KEYCLOAK_IDENTITY_LEGACY":
                cookie_dict["KEYCLOAK_IDENTITY_LEGACY"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "KEYCLOAK_SESSION":
                cookie_dict["KEYCLOAK_SESSION"] = cookie.__dict__["value"]
            if cookie.__dict__["name"] == "KEYCLOAK_SESSION_LEGACY":
                cookie_dict["KEYCLOAK_SESSION_LEGACY"] = cookie.__dict__["value"]
        
        update_conf("keycloak_cookie", cookie_dict)
        
    else:
        reporter.error("Failed to grab the cookie")
        return

def construct_cassdoor_cookie(url):

    resp = requests.get(url)
    if resp.ok:
        csrf_cookie_cassdor = cookies_from_dict(resp.cookies)
        payload={"application": "myclient", "autoSignin": True, "organization": "built-in", "password": "123", "phonePrefix": "86", "samlRequest": "", "type": "code", "username": "admin"}
        resp_auth = requests.post(url, cookies=csrf_cookie_cassdor, json=payload)
        update_conf("keycloak_cookie", csrf_cookie_cassdor)