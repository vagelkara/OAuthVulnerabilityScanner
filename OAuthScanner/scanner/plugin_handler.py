from email import header
from urllib.parse import quote_plus
import requests
from time import sleep
from plugins.redirect_fuzzer import redirect_fuzzer
from reporter import Reporter
from utils.utils import construct_cookie, define_schema, has_key, request_builder,read_key_from_config,check_responses,remove_key_from_conf, requestErrorReporter,request_urls,log
from utils.pkce_calc import generate_pkce_pair

reporter = Reporter("plugin handler")

class temp_request:
    def __init__(self,sc,t):
        self.status_code = sc
        self.text = t

class Plugin_handler:

    def __init__(self, settings, args, nav, avoid_replays, proxy, pkce, log):
        self.args = args
        self.log = log
        self.avoid_replays = avoid_replays
        self.nav = nav
        if proxy:
            self.proxies = {
                "http": proxy,
                "https": proxy
            }
        else:
            self.proxies = None
        self.settings = settings
        self.pkce = pkce
        self.oauth_vendor = has_key('oauth_vendor',settings)
        self.schema = define_schema(self.oauth_vendor)
        self.authorization_endpoint = read_key_from_config('authorization_endpoint') 
        self.token_endpoint = read_key_from_config('token_endpoint')
        self.clientid = has_key('client_id',settings)
        self.extra_args = has_key('extra_args',settings)
        
        # PKCE related initializations
        self.code_verifier = has_key('code_verifier',self.extra_args) if has_key('code_verifier',self.extra_args) else ''
        self.code_verifier = 'A'*96 if pkce and not self.code_verifier else self.code_verifier
        cc = ''
        if self.code_verifier:
            cc = generate_pkce_pair(self.code_verifier)
        self.code_challenge = cc
        self.challenge_method = 'S256' if cc else ''

        if self.clientid is None:
            reporter.error("ClientId not found please provide!")
        self.redirect_uri = has_key('redirect_uri',settings)
        if self.redirect_uri is None:
            self.redirect_uri ='http://malserver.com:4200/callback'
        self.openid = read_key_from_config("openId")
        self.url = self.primitive_url_construction()

    def primitive_url_construction(self):
        
        scope = 'profile email'
        scope += ' openid' if self.openid else ''
        scope =  has_key('scope',self.extra_args) if has_key('scope',self.extra_args) else scope
        scope_encoded = quote_plus(scope)
        state= has_key('state',self.extra_args) if has_key('state',self.extra_args) else f'123456'
        nonce= has_key('nonce',self.extra_args) if has_key('nonce',self.extra_args) else f'something_expected'
        url = request_builder(self.schema,
                    self.authorization_endpoint, 
                    self.clientid, 
                    self.redirect_uri, 
                    nonce, 
                    state,
                    self.challenge_method,
                    self.code_challenge,
                    scope_encoded)
        return url

    def try_all_payloads(self,endpoint,headers,auth_code,client_secret):
        
        auth_code = self.get_new_auth_code()
        p1 = f"&client_id={self.clientid}&client_secret={client_secret}&redirect_uri={self.redirect_uri}&grant_type=authorization_code"
        payload1 = f"code={auth_code}" + p1
        log(payload1, self.log)
        r1 = self.request_resource(endpoint,payload1,headers)
        log(f'first attempt {r1}', self.log)
        if r1.ok:
            self.temp_payload = p1
            return r1

        if self.avoid_replays:
            construct_cookie(self.url,self.nav)
            auth_code = read_key_from_config('extracted_code')

        auth_code = self.get_new_auth_code()
        p2 = f"&grant_type=authorization_code&redirect_uri={self.redirect_uri}&code_verifier={self.code_verifier}&client_id={self.clientid}&client_secret={client_secret}"
        payload2 = f"code={auth_code}" + p2
        r2 = self.request_resource(endpoint,payload2,headers)
        log(f'second attempt {r2}', self.log)
        if r2.ok:
            self.temp_payload = p2
            return r2
        
        return r2
        
    def request_resource(self,e,p,h):
        resp = requests.request("POST", e, data=p, headers=h, proxies=self.proxies)
        if resp.ok:
            reporter.debug("Successfull payload, procceed with access token exchange")
        else:
            reporter.error(resp.content)
        return resp

    def get_new_auth_code(self):
        construct_cookie(self.url,self.nav)
        self.auth_cookie = read_key_from_config('cookie')
        log(f"old code {read_key_from_config('extracted_code')}", self.log)
        r = requests.get(self.url, cookies=self.auth_cookie, proxies=self.proxies)
        sleep(1)
        return read_key_from_config('extracted_code')

    '''Active Scan'''
    def openRedirectScan(self):
        '''Scan for open redirect issues on 'redirect_uri' parameter'''
        print('\n')
        reporter.debug("----------Try OpenRedirect Scan----------")

        construct_cookie(self.url,self.nav)
        self.auth_cookie = read_key_from_config('cookie')    
        rf = redirect_fuzzer(self.url, self.auth_cookie, self.schema)
        rf.fuzz()

    def pkceScan(self):
        #   Only supported for Keycloak at now need to be extended
        #   @requires authentication user credentials (username/password) in settings.json
        '''Scan to detect PKCE downgrade issues on authorization requests OpenID/OAuth'''
        
        scope = 'profile email'
        scope += ' openid' if self.openid else ''
        scope =  has_key('scope',self.extra_args) if has_key('scope',self.extra_args) else scope
        scope_encoded = quote_plus(scope)
        state= has_key('state',self.extra_args) if has_key('state',self.extra_args) else f'123456'
        nonce= has_key('nonce',self.extra_args) if has_key('nonce',self.extra_args) else f'something_expected'
        
        log(self.url, self.log)
        print('\n')
        reporter.debug("----------Try PKCE Scan----------")
        new_url = request_builder(self.schema,
                    self.authorization_endpoint, 
                    self.clientid, 
                    self.redirect_uri, 
                    nonce, 
                    state,
                    'plaintext',
                    '',
                    scope_encoded)

        if self.nav:
            r1,r2 = request_urls(self.url,new_url, self.nav)
            r = temp_request(r1,"")
            r_new = temp_request(r2,"")
        else:
            construct_cookie(self.url,self.nav)
            self.auth_cookie = read_key_from_config('cookie') 
            
            try:
                r = requests.get(self.url, cookies=self.auth_cookie, proxies=self.proxies)
            except:
                e = requestErrorReporter(None, 'Check if malicious listener is running')
                reporter.error(e)
                return
            
            r_new = requests.get(new_url, cookies=self.auth_cookie, proxies=self.proxies)
            
        d = check_responses(r,r_new)
        equal_key = True if 'equals' in d else False
        
        if d["status_code"] == True and r.status_code >= 400:
            reporter.error('Downgrade Attacks are not applicable')
        elif d["status_code"] == True and equal_key:
            if self.openid == True:
                reporter.debug('OpenID PKCE Downgrade Attacks are potentially applicable or maybe PKCE does not supported')
            else:
                reporter.debug('OAuth PKCE Downgrade Attacks are potentially applicable or maybe PKCE does not supported')
        else:# status code != True          
            reporter.error('Downgrade Attacks are not applicable...')

    def codeReplayScan(self):
        # Only applicable in auth_code grant type
        # required fields (client_id/client_secret and authorization_code)
        '''Scan for authorization code replay issues on token requests for OAUTHv2 and OpenID Authorization Code and Hybrid Flows'''
        
        print('\n')
        reporter.debug("----------Try Code Replay Scan----------")
        client_secret = has_key('client_secret',self.settings)
        
        construct_cookie(self.url,self.nav)
        self.auth_cookie = read_key_from_config('cookie') 
        
        if not client_secret:
            reporter.error("Client Secret doesn't provided - It is required for Code Replay Scan")
            return
        else:
            auth_code = read_key_from_config('extracted_code')
            if auth_code:
                pass
            else:
                reporter.error("Auth code not found - It is required for Code Replay Scan")
                return

        headers = {'content-type': "application/x-www-form-urlencoded"}
        log(self.url, self.log)
        r = self.try_all_payloads(self.token_endpoint,headers,auth_code,client_secret)
        if r.ok:
            auth_code = self.get_new_auth_code()
            self.payload = f"code={auth_code}" + self.temp_payload
            first_response = requests.request("POST", self.token_endpoint, data=self.payload, headers=headers, proxies=self.proxies)
            log(f'f1:{first_response}, {self.payload}', self.log)
            second_response = requests.request("POST", self.token_endpoint, data=self.payload, headers=headers, proxies=self.proxies)
            log(f'f2:{second_response}, {self.payload}', self.log)

            r = check_responses(first_response, second_response)
            if first_response.ok or second_response.ok:
                if r["status_code"] != True:
                    reporter.error("Replay Attacks - Not vulnerable ")
                else:
                    if r["equals"] == True:
                        reporter.debug("Replay Attacks - Vulnerability detected")
                    else:
                        reporter.info("Replay Attacks - Needs further investigation")
            else:
                reporter.error("Replay Attacks - Not Vulnerable")
        else:
            reporter.error("Replay Attacks - Any of the payloads were correct for this server")
        
    def scopeScan(self):
        '''TODO: we have to check different scopes (a) check a non existing scope (b) check all available'''
        '''Scan for improper input validation issues of 'scope' parameter in token requests'''
        '''use "test" attribute as one untrusted'''
        '''TODO : also could have to test the list from scopes from (config) and to inform that client has access to everything!'''
        
        print('\n')
        reporter.debug("----------Try Scope Scan----------")

        scope = 'profile email'
        scope += ' openid' if self.openid else ''
        scope =  has_key('scope',self.extra_args) if has_key('scope',self.extra_args) else scope
        scope_encoded = quote_plus(scope)
        
        # url = request_builder(self.schema,
        #             self.authorization_endpoint, 
        #             self.clientid, 
        #             self.redirect_uri, 
        #             '', 
        #             '',
        #             '',
        #             '',
        #             scope_encoded)
        
        auth_code = self.get_new_auth_code()
        
        if auth_code is None:
            reporter.error("Unable to track a valid auth code")
            return
        else: 
            remove_key_from_conf("extracted_code")
            reporter.debug("auth code retrieved successfully")
            
        client_secret = has_key('client_secret',self.settings)
        if not client_secret:
            reporter.error("Client Secret doesn't provided - It is required for Scope Scan")
            return
        
        headers = {'content-type': "application/x-www-form-urlencoded"}
        
        reporter.info("Scope scan : Try to exchange to an access token...")
        resp = self.try_all_payloads(self.token_endpoint,headers,auth_code, client_secret)
        
        if resp.ok:
            if self.openid:
                reporter.debug("Scope scan: OpenID improperly validates the scope attributes!")
            else:
                reporter.debug("Scope scan: OAuth2 improperly validates the scope attributes!")
        else:
            reporter.error("Scope scan: Failure in exchange to an access token")
        # na prospa8hsoume na kanoume extract to redirection url
        # extract to redirection host/path
        # 
        # 1.  an exei authorization param : extract (alla mallon edw exoume constraint giati to burp 
        # ta pairnei apo to interception)
        # 
        # 2. an parousiastike scope param tote pros8ese th sto scope payload / an uparxei openid pros8ese to
        #  
        # 3. kane retrive to oauth2 auth code pou epistrefetai apo to HTTP response 
        # 
        # 4. xtise ena http POST token me ka8e auth code pou vre8hke (8elei authentication)
        # an to status code einai != 200 tote prospa8hse me get
        pass

    def nonceScan(self):
        '''Scan for nonce duplicate replay and nonce not controlled issues for the requests of all OpenID Flows'''
        # TODO: na tsekaroume ola ta diaforetika status sta response types sta diaforetika requests
        
        print('\n')
        reporter.debug("----------Try Nonce Scan----------")

        if self.openid:
            
            scope = 'profile email'
            scope += ' openid' if self.openid else ''
            scope =  has_key('scope',self.extra_args) if has_key('scope',self.extra_args) else scope
            scope_encoded = quote_plus(scope)
            state= has_key('state',self.extra_args) if has_key('state',self.extra_args) else f'123456'
            nonce= has_key('nonce',self.extra_args) if has_key('nonce',self.extra_args) else f'something_expected'

            url1 = request_builder(self.schema,
                        self.authorization_endpoint, 
                        self.clientid, 
                        self.redirect_uri, 
                        nonce, 
                        state,
                        '',
                        '',
                        scope_encoded)
            
            construct_cookie(url1,self.nav)
            self.auth_cookie = read_key_from_config('cookie') 
            
            r1 = requests.get(url1, cookies=self.auth_cookie, proxies=self.proxies)
            r2 = requests.get(url1, cookies=self.auth_cookie, proxies=self.proxies)

            d = check_responses(r1,r2)
            equal_key = True if 'equals' in d else False
            if d["status_code"] == True:
                if equal_key:
                    reporter.debug("Nonce Replay Scan - OpenId Flow allows the nonce resusage")
                else:
                    reporter.info("Nonce Replay Scan - Needs further investigation")
            else:
                reporter.error("Nonce Replay Scan - Not vulnerable")

            url2 = request_builder(self.schema,
                        self.authorization_endpoint, 
                        self.clientid, 
                        self.redirect_uri, 
                        '', 
                        state,
                        '',
                        '',
                        scope_encoded)
            
            r3 = requests.get(url2, cookies=self.auth_cookie, proxies=self.proxies)
            
            d1 = check_responses(r1,r3)
            equal_key = True if 'equals' in d1 else False
            if d1["status_code"] == True:
                if equal_key:
                    reporter.debug("Nonce Server Scan - Nonce Parameter is NOT Evaluated!")
                else:
                    reporter.info("Nonce Server Scan - Needs further investigation")
            else:
                reporter.error("Nonce Server Scan - Nonce Parameter is Evaluated")
            
        else: 
            reporter.error("OpenId doesn't supported")

    '''@main'''
    def active_scan(self):
        '''Start Active Scan for each OAUTHv2/OpenID vulnerability and common misconfiguration'''
        # authcode = OAuthCode(self.settings)
        # authcode.client_enumeration()
        if isinstance(self.args, list):
            args = self.args
        else:
            args = []
            args.append(self.args)

        if 'ALL' in args:
            self.pkceScan() #?
            self.codeReplayScan() #v
            self.nonceScan() #v
            self.scopeScan() #?
            try:
                self.openRedirectScan()
            except:
                reporter.error("Couldn't manage to finish open redirect Scan")
        else:
            if 'P' in args:
                self.pkceScan()
            if 'N' in args:
                self.nonceScan()
            if 'S' in args:
                self.scopeScan()
            if 'RP' in args:
                self.codeReplayScan()
            if 'RD' in args:
                try:
                    self.openRedirectScan()
                except:
                    reporter.error("Couldn't manage to finish open redirect Scan")
            if 'NC' in args:
                self.get_new_auth_code()
        
        