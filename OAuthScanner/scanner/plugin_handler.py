from urllib.parse import quote_plus
import requests
import json
from time import sleep
from plugins.redirect_fuzzer import redirect_fuzzer
from plugins.authCode import OAuthCode
from reporter import Reporter
from utils.utils import build_at_requests, construct_cookie, define_schema, has_key, request_builder,read_key_from_config,check_responses, requestErrorReporter,request_urls,log, decisionmaker, get_query_params, get_origin
from utils.pkce_calc import generate_pkce_pair

reporter = Reporter("plugin handler")

class temp_request:
    def __init__(self,sc,t):
        self.status_code = sc
        self.text = t

class Plugin_handler:

    def __init__(self, settings, args, nav, avoid_replays, proxy, pkce, log):
        self.args = args
        self.log = log
        self.avoid_replays = avoid_replays
        self.nav = nav
        self.pkce = pkce
        self.openid = read_key_from_config("openId")
        scope = 'profile email'
        scope += ' openid' if self.openid else ''
        self.default = {
            "scope": scope,
            "state": "123456",
            "nonce": "something_expected",
            "redirect_uri":"http://malserver.com:4200/callback",
            "code_verifier": 'A'*96 if pkce else "",
            "challenge_method": ""
        }
        self.extra_args = has_key('extra_args',settings)

        if proxy:
            self.proxies = {
                "http": proxy,
                "https": proxy
            }
        else:
            self.proxies = None
        self.settings = settings
        self.oauth_vendor = has_key('oauth_vendor',settings)
        self.schema = define_schema(self.oauth_vendor)
        self.authorization_endpoint = read_key_from_config('authorization_endpoint') 
        self.token_endpoint = read_key_from_config('token_endpoint')
        self.clientid = has_key('client_id',settings)
        self.clientsecret= has_key('client_secret',settings)

        if self.clientid is None:
            reporter.error("ClientId not found please provide!")

        self.url = self.url_construction()

    def url_construction(self, options = {}):
        log(f"Options:{options}",self.log)
        url_obj = decisionmaker(options,self.extra_args,self.default)
        
        cc =  url_obj['code_challenge'] if has_key( 'code_challenge', url_obj) else ''
        if has_key( 'code_verifier', url_obj):
            cc = generate_pkce_pair(url_obj['code_verifier'])
        code_challenge = url_obj['code_verifier'] if url_obj['code_verifier'] else cc 
        clientid = url_obj['client_id'] if has_key( 'client_id', url_obj) else self.clientid

        if url_obj['challenge_method'] != '':
           challenge_method = url_obj['challenge_method']
        elif cc:
            challenge_method = 'S256'
        else:
            challenge_method = ''

        log(f'Challenge method: {challenge_method}',self.log)
        log(f'code_challenge : {code_challenge}',self.log)

        enc_scope = quote_plus(url_obj['scope']) if url_obj['scope'] else ''
        self.redirect_uri = url_obj['redirect_uri']
        self.code_verifier = url_obj['code_verifier']
        log(f'SCHEMA: {self.schema}',self.log)
        url = request_builder(self.schema,
                    self.authorization_endpoint, 
                    clientid, 
                    url_obj['redirect_uri'], 
                    url_obj['nonce'], 
                    url_obj['state'],
                    challenge_method,
                    code_challenge,
                    enc_scope)
        return url

    def request_resource(self,e,p,h):
        resp = requests.request("POST", e, data=p, headers=h, proxies=self.proxies, verify=False)
        if resp.ok:
            reporter.debug("Successfull payload, procceed with access token exchange")
        else:
            reporter.error(resp.content)
        return resp

    def get_new_auth_cookie(self):
        construct_cookie(self.url,self.nav)
        self.auth_cookie = read_key_from_config('cookie')

    def get_new_auth_code(self):
        self.get_new_auth_cookie()
        log(f"old code {read_key_from_config('extracted_code')}", self.log)
        r = requests.get(self.url, cookies=self.auth_cookie, proxies=self.proxies, verify=False)
        sleep(1)
        return read_key_from_config('extracted_code')

    '''Active Scan'''
    def openRedirectScan(self):
        '''Scan for open redirect issues on 'redirect_uri' parameter'''
        print('\n')
        reporter.debug("----------Try OpenRedirect Scan----------")
        reporter.warning("If scan is running through navigator this scan has issues - check Readme#notes ")

        self.get_new_auth_cookie()    
        rf = redirect_fuzzer(self.url, self.auth_cookie, self.schema)
        rf.fuzz()
    
    def pkceScanSuite(self):
        print('\n')
        reporter.debug("----------Try PKCE Scan----------")
        opts = []
        test1 = {
            'challenge_method':'plaintext',
            'code_challenge':'A'*96
        }
        test2 = {
            'challenge_method':'plaintext',
            'code_challenge':'A'*3
        }
        test3 = {
            'challenge_method':'plain',
            'code_challenge':'A'*96
        }
        opts.append(test1)
        opts.append(test2)
        opts.append(test3)
        for option in opts:
            r = self.pkceScan(option)
            if r:
                break


    def pkce_test_casdoor(self,url):
        post_api_path = '/api/login'
        n = get_origin(url)
        q = get_query_params(url)
        rep = {
            'client_id' : 'clientId',
            'redirect_uri' : 'redirectUri',
            'response_type' : 'responseType',
            'chal_method' : 'code_challenge_method'
        }
        post_url = f'{n}{post_api_path}?{q}'
        
        for attr, value in rep.items():
            post_url = post_url.replace(attr, value)
        
        data={"application": "myclient", "autoSignin": True, "organization": "built-in", "password": self.settings["password"], "phonePrefix": "86", "samlRequest": "", "type": "code", "username": self.settings["username"]}
        r = requests.post(post_url, json=data, proxies=self.proxies, verify=False)
        return r

    def pkceScan(self, options):
        #   Only supported for Keycloak at now need to be extended
        #   @requires authentication user credentials (username/password) in settings.json
        '''Scan to detect PKCE downgrade issues on authorization requests OpenID/OAuth'''
        
        reporter.debug(f"----------#Test - {options['challenge_method']}:{options['code_challenge']}----------")
        new_url = self.url_construction(options)

        log(f'PKCEd: {new_url}',self.log)
        log(f'Normal: {self.url}',self.log)

        if self.nav:
            r1,r2 = request_urls(self.url,new_url, self.nav)
            r = temp_request(r1,"")
            r_new = temp_request(r2,"")
        else:
            self.get_new_auth_cookie()
            
            if self.oauth_vendor=="casdoor":
                r = self.pkce_test_casdoor(self.url)
                r_new = self.pkce_test_casdoor(new_url)
                
            else:
                try:
                    r = requests.get(self.url, cookies=self.auth_cookie, proxies=self.proxies, verify=False)
                except:
                    e = requestErrorReporter(None, 'Check if malicious listener is running')
                    reporter.error(e)
                    return
                
                r_new = requests.get(new_url, cookies=self.auth_cookie, proxies=self.proxies, verify=False)
            
        d = check_responses(r,r_new)
        equal_key = True if 'equals' in d and d['equals']==True else False
        
        if d["status_code"] == True and r.status_code >= 400:
            reporter.error('Downgrade Attacks are not applicable')
            return False
        elif d["status_code"] == True and equal_key:
            if self.openid == True:
                reporter.debug('OpenID PKCE Downgrade Attacks are potentially applicable or maybe PKCE does not supported')
            else:
                reporter.debug('OAuth PKCE Downgrade Attacks are potentially applicable or maybe PKCE does not supported')
            return True
        else:# status code != True          
            reporter.error('Downgrade Attacks are not applicable...')
            return False

    def scopeScan(self):
        '''TODO: we have to check different scopes (a) check a non existing scope (b) check all available'''
        '''Scan for improper input validation issues of 'scope' parameter in token requests'''
        '''use "test" attribute as one untrusted'''
        '''TODO : also could have to test the list from scopes from (config) and to inform that client has access to everything!'''
        
        print('\n')
        reporter.debug("----------Try Scope Scan----------")

        headers = {'content-type': "application/x-www-form-urlencoded"}
        
        reporter.info("Scope scan : Try to exchange to an access token...")
        
        self.get_new_auth_cookie()
        r1 = requests.get(self.url, cookies=self.auth_cookie, proxies=self.proxies, verify=False)
        
        # use options to create a new request
        self.random_scope_check()

    def nonceScan(self):
        '''Scan for nonce duplicate replay and nonce not controlled issues for the requests of all OpenID Flows'''
        
        print('\n')
        reporter.debug("----------Try Nonce Scan----------")

        if self.openid:
            
            self.get_new_auth_cookie()
            
            r1 = requests.get(self.url, cookies=self.auth_cookie, proxies=self.proxies, verify=False)
            r2 = requests.get(self.url, cookies=self.auth_cookie, proxies=self.proxies, verify=False)

            d = check_responses(r1,r2)
            equal_key = True if 'equals' in d else False
            if d["status_code"] == True:
                if equal_key:
                    reporter.debug("Nonce Replay Scan - OpenId Flow allows the nonce resusage")
                else:
                    reporter.info("Nonce Replay Scan - Needs further investigation")
            else:
                reporter.error("Nonce Replay Scan - Not vulnerable")
            
            options = {
                'nonce': ''
            }

            url2 = self.url_construction(options)
            r3 = requests.get(url2, cookies=self.auth_cookie, proxies=self.proxies, verify=False)
            
            d1 = check_responses(r1,r3)
            equal_key = True if 'equals' in d1 else False
            if d1["status_code"] == True:
                if equal_key:
                    reporter.debug("Nonce Server Scan - Nonce Parameter is NOT Evaluated!")
                else:
                    reporter.info("Nonce Server Scan - Needs further investigation")
            else:
                reporter.error("Nonce Server Scan - Nonce Parameter is Evaluated")
            
        else: 
            reporter.error("OpenId doesn't supported")

    def random_scope_check(self):
        options = {
            'scope':'something_undefined'
        }
        random_scope_url = self.url_construction(options)
        self.get_new_auth_cookie()
        
        log(random_scope_url,self.log)

        r2 = requests.get(random_scope_url, cookies=self.auth_cookie, proxies=self.proxies, verify=False)

        if r2.ok:
            if self.openid:
                reporter.debug("Scope scan: OpenID improperly validates the scope attributes!")
            else:
                reporter.debug("Scope scan: OAuth2 improperly validates the scope attributes!")
        else:
            reporter.error("Scope scan: Not vulnerable to random scope attacks")

    def codeReplayScan(self):
        print('\n')
        reporter.debug("----------Try Code Replay Scan----------")
        client_secret = has_key('client_secret',self.settings)
        
        if not client_secret:
            reporter.error("Client Secret doesn't provided - It is required for Code Replay Scan")
            return
        _self = self
        reqs = build_at_requests(_self)
        r = False
        for raw in reqs:
            auth_code = self.get_new_auth_code()
            enc_r = self.encapsulate_auth_to_template(raw,auth_code)
            res = self.try_redeem_auth_to_at(enc_r,raw)
            r = r or res
            if res:
                reporter.debug("Access_token found! Try to replay...")
                res2 = self.try_redeem_auth_to_at(enc_r,raw)
                if res2:
                    reporter.debug("Replay Attacks - Vulnerability detected")
                else:
                    reporter.error("Replay Attacks - Not Vulnerable")
                break
        
        if r is False:
            reporter.error("Try 'navigation' mode")

    def clientFuzzing(self):
        print('\n')
        reporter.debug("----------Try Client Fuzzing----------")
        reporter.warning("In casdoor's case we have a known False Positive - check Readme#notes")
        options = {
            'client_id':'FUZZ'
        }
        
        new_url = self.url_construction(options)
        
        print(new_url)
        authcode = OAuthCode(new_url,self.proxies)
        authcode.client_enumeration()
        # client_enumeration(self.url)

    def encapsulate_auth_to_template(self,r,auth_code):
        r_token, r_data = r
        if r_token:
            endpoint = self.token_endpoint + f'?code={auth_code}' + r_token
        else:
            endpoint = self.token_endpoint
            
        if r_data:
            data = f'code={auth_code}' + r_data
        else:
            data = ''
        
        return endpoint,data
        
    def try_redeem_auth_to_at(self,req, raw):
        endpoint, data = req
        headers = {'content-type': "application/x-www-form-urlencoded"}
        r = requests.request("POST",
                        endpoint,
                        data=data,
                        headers=headers,
                        proxies=self.proxies,
                        verify=False)
        triaged = self.triage_response(r)
        if triaged:
            return raw
        else:
            return False
        
        
    #Boolean
    def triage_response(self,r):
        if r.ok:
            try:
                parsed_r = json.loads(r.content)
                log(parsed_r, self.log)
                if not "access_token" in parsed_r:
                    return False
                elif 'error' in parsed_r["access_token"]:
                    return False
                else:
                    return True
                    #obtained access token
                
            except:
                reporter.error("parsing failed")
            
        else:
            return False

        

    '''@main'''
    def active_scan(self):
        '''Start Active Scan for each OAUTHv2/OpenID vulnerability and common misconfiguration'''
        if isinstance(self.args, list):
            args = self.args
        else:
            args = []
            args.append(self.args)

        if 'ALL' in args:
            self.pkceScanSuite()
            self.codeReplayScan() 
            self.nonceScan() 
            self.scopeScan() 
            self.clientFuzzing()
            try:
                self.openRedirectScan()
            except:
                reporter.error("Couldn't manage to finish open redirect Scan")
        else:
            if 'FC' in args:
                self.clientFuzzing()
            if 'P' in args:
                self.pkceScanSuite()
            if 'N' in args:
                self.nonceScan()
            if 'S' in args:
                self.scopeScan()
            if 'RP' in args:
                self.codeReplayScan()
            if 'RD' in args:
                try:
                    self.openRedirectScan()
                except:
                    reporter.error("Couldn't manage to finish open redirect Scan")
        